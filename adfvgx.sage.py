# This file was *autogenerated* from the file adfvgx.sage
from sage.all_cmdline import *   # import sage library
_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_65 = Integer(65); _sage_const_48 = Integer(48); _sage_const_10 = Integer(10); _sage_const_26 = Integer(26); _sage_const_6 = Integer(6)
import random
import math
import numpy as np

def make_num_list():
	num_list = list()
	for row in range(6):
		for col in range(6):
			num_list.append((row,col))
	return num_list

def make_key():
	xy_letters = ['A','D','F','G','V','X']

	all_letters = []

	#key_letters = [[]];

	#creates a list to represent each spot in the key.
	num_list = make_num_list()
	x = _sage_const_0 ;
	y = _sage_const_0 ;

	#puts all of the letters and numbers into an array
	for letter in range(_sage_const_10 ):
		all_letters.append(chr(letter + _sage_const_48 ))
	for letter in range(_sage_const_26 ):
		all_letters.append(chr(letter + _sage_const_65 ))
	#creates a
	key = np.chararray((6,6))
	size = len(num_list)
	#randomly puts the key together
	for spot in num_list:
		#matrix indexes
		row = spot[0]
		col = spot[1]
		#spot in the all_letters list
		rand_spot = random.randint(0,size-1)
		#random letter
		rand_letter = all_letters[rand_spot]
		#remove the letter from the list
		all_letters.remove(rand_letter)
		#inserting into a numpy matrix (starts at (0,0), not (1,1)
		key[row,col] = rand_letter
		#subtracts one from size
		size-=1
	return key



	"""
	while len(all_letters) > _sage_const_0 :
		placer = randint(_sage_const_0 , len(all_letters))
		key_letters[x][y] = all_letters.pop(placer)
		y += _sage_const_1
		if y == _sage_const_6 :
			y = _sage_const_0
			x += _sage_const_1
			"""


def get_spot(key, letter):
	"""
	Gets the location of a character of a letter on the key
	Args:
		key(matrix): the key for the encryption algoritm, 6x6 matrix
		letter(string): the character that is being searched for.
	Returns:
		row,col(tuple of ints): the location of the character in the matrix
	"""

	go = True
	for row in range(6):
		for col in range(6):
			if(letter == key[row,col]):
				return row,col


def get_letter_encrypt(key, letter):
	"""
	Gets the encrypted form of the letter
	Args:
		key(matrix): the key for the encryption algorithm, 6x6 matrix
		letter(string): the letter that is being encrypted
	Returns:
		tuple: the two characters that directly reflects the matrix.
	"""

	xy_letters = ['A','D','F','G','V','X']
	#the indexes of the letter on the key
	top,bottom = get_spot(key, letter)
	#the new encryted spot
	# in the form of a tuple, this could be changed for something nicer...
	return xy_letters[top],xy_letters[bottom]


def parse(message):
	message = message.upper()
	outmessage = ""
	for char in message:
		if isalpha(char) or isdigit(char):
			outmessage += char
	return outmessage

def col_encrypt(key,message):
	"""
	Creates a list of the second step in the encryption.
	"""
	col_list = list()
	print key
	for char in message:
		letter1, letter2 = get_letter_encrypt(key,char)
		col_list.append(letter1)
		col_list.append(letter2)
	return col_list

def horizontal_matrix_encrypt(word_key, col_list):
	#Gets the size of the matrix needed
	col_num = len(word_key)
	row_num = math.ceil((len(col_list)) / float(len(word_key)))

	#fills the matrix with all X's
	encrypted = np.chararray((int(row_num),col_num))
	encrypted[:] = 'X'
	row = 0
	col = 0
	for iteration in range(len(col_list)):
		encrypted[row,col] = col_list[iteration]
		if(col_num-1 == col):
			col = 0
			row +=1
		else:
			col+=1
	print encrypted
	print
	alphabetize(word_key, encrypted)

def create_dict_order(word_key):
	char_order = dict()
	spot = 0
	for char in word_key:
		char_order[char] = spot
		spot+=1
	return char_order

def swap_col(matrix_swap, encrypt, col_num, new_col):
	for i in range(3):
		encrypt[i,new_col] = matrix_swap[i,col_num]
	return encrypt

def alphabetize(word_key, encrypted):
	lst = list()
	for char in word_key:
		lst.append(char)
	lst.sort()
	spot_dict = create_dict_order(word_key)
	final = np.copy(encrypted)
	for spot in range(len(word_key)):
		old_col = spot_dict[lst[spot]]
		final = swap_col(encrypted,final,old_col,spot)
	print final
	set_string(final)


def set_string(encrypt_string):
	final_string = ""
	row_num, col_num = encrypt_string.shape
	for row in range(row_num):
		for col in range(col_num):
			final_string+= encrypt_string[row,col]
	print final_string

def encrypt(message, key):
	#probably should be parsing stuff here...
	#need to take out spaces and such
	message = parse(message)
	col_list = col_encrypt(key,message)
	return horizontal_matrix_encrypt(word_key, col_list)

def decrypt(ciphertext, keyword, key):
	# takes ciphertext, returns playtext.
	decKeyword = sorted(keyword)
	wKeyRows = floor(len(ciphertext) / len(keyword))
	
	return

def main():
	word_key = "ENCRYPT"
	plaintext = "seemeat10"
	print word_key
	key = make_key()
	ciphertext = encrypt(plaintext, key)

	decrypted = decrypt(ciphertext, word_key, key)
	print "Decrypted: " + decrypted

main()
